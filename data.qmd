# Data

## Description
## Missing value analysis
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
library(memoise)
```
```{r}
# library(RSocrata)
# library(dplyr)

# options(timeout = 600)

# base_url <- "https://data.cityofnewyork.us/resource/erm2-nwe9.json"

# get_month_data <- function(year, month) {
#   start <- sprintf("%d-%02d-01T00:00:00", year, month)
#   # end = first day of next month
#   if (month == 12) {
#     end <- sprintf("%d-01-01T00:00:00", year + 1)
#   } else {
#     end <- sprintf("%d-%02d-01T00:00:00", year, month + 1)
#   }

#   url <- sprintf(
#     "%s?$where=created_date >= '%s' AND created_date < '%s'",
#     base_url, start, end
#   )
#   message("Fetching: ", start, " to ", end)
#   read.socrata(url)
# }

# # Example: all months of 2023
# months <- 1:12
# list_2023 <- lapply(months, function(m) get_month_data(2023, m))
# data_2023 <- bind_rows(list_2023)
# list_2024 <- lapply(months, function(m) get_month_data(2024, m))
# data_2024 <- bind_rows(list_2024)
# combined <- rbind(data_2023,data_2024)
# saveRDS(combined, "nyc_311_data.rds")
```
```{r}
combined=combined <- readRDS("nyc_311_data.rds")
combined=combined <- readRDS("nyc_311_data.rds")
```


```{r}
missing_values_summary <- colSums(is.na(combined))
missing_columns <- missing_values_summary[missing_values_summary > 0]
missing_table <- data.frame(
  Column = names(missing_columns),
  MissingCount = as.numeric(missing_columns)
)
sorted_table <- missing_table |>
arrange(desc(MissingCount))
print(sorted_table)
```


```{r}
miss_by_col_all <- combined |>
  summarise(across(everything(), \(x) sum(is.na(x)))) |>
  pivot_longer(everything(), names_to = "column", values_to = "missing_n") |>
  mutate(total_n = nrow(combined),
         missing_rate = missing_n / total_n) |>
  dplyr::arrange(desc(missing_n))

top_missing_rate <- miss_by_col_all |>
slice_max(missing_rate, n = 25)

ggplot(top_missing_rate, aes(x = reorder(column, missing_rate), y = missing_rate)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Top columns by missingness rate (pre-selection)",
    x = NULL,
    y = "Missingness rate"
  )

missing_threshold <- 0.60
cols_to_drop_by_missing <- miss_by_col_all |>
  filter(missing_rate > missing_threshold) |>
  pull(column)
```
The above horizontal bar graph gives a relative view of missing values in all the columns of the dataset. Missing values can, of course, complicate the analysis; however, in our case, the columns with a high number of missing values are not critical to our primary objectives. The data in these columns—such as taxi_company_borough, road_ramp,bridge_highway_direction, bridge_highway_name  bridge_highway_segment,taxi_pick_up_location,vehicle_type,facility_type as supporting information rather than core data required for analysis.

For example, columns like bridge_highway_direction only provides metadata about the bridge highway, which is not directly related to analyzing 311 trends . Thus, we can safely drop these columns without significantly impacting our analysis.
```{r}
set.seed(42)
sampled_data <- combined[sample(1:nrow(combined), 5000), ]

missing_long <- as.data.frame(is.na(sampled_data)) |>
  pivot_longer(cols = everything(), names_to = "Column", values_to = "IsMissing")

missing_long <- cbind(RowIndex = rep(1:nrow(sampled_data), times = ncol(sampled_data)), missing_long)

# Plotting heatmap of missing data
ggplot(missing_long, aes(x = Column, y = RowIndex, fill = IsMissing)) +
  geom_tile() +
  scale_fill_manual(values = c("FALSE" = "white", "TRUE" = "red"), name = "Missing") +
  labs(title = "Heatmap of Missing Data (Sampled Rows)",
       x = "Columns",
       y = "Row Index") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```
The above missing value heatmap shows that missing data is concentrated only in certain columns. The rest of the columns have little to no missing data. This helps us streamline the data cleaning process.
```{r}
valid_boros <- c("MANHATTAN", "BROOKLYN", "QUEENS", "BRONX", "STATEN ISLAND")

# ---- Diagnostic Plot: Borough counts ----
ggplot(combined, aes(x = borough)) +
  geom_bar(fill = "seagreen") +
  labs(
    title = "Borough Distribution of 311 Complaints",
    x = "Borough",
    y = "Count"
  ) +
  theme_minimal()

# Drop rows not in valid NYC borough list
df_clean_final <- combined |>
  filter(borough %in% valid_boros)

unique(df_clean_final$borough)
```


### Data Cleaning
Based on our results above we have decided to remove following columns from our data-set as they are either not useful to us or have a lot of missing values.

The columns that we are dropping:
taxi_company_borough, road_ramp,bridge_highway_direction, bridge_highway_name, bridge_highway_segment,taxi_pick_up_location,vehicle_type,facility_type, due to high missing values and low relevance to our analysis.
```{r}
#label
df_clean_final <- df_clean_final |>
  dplyr::select(
    unique_key, created_date, closed_date, resolution_action_updated_date,
    agency, agency_name, complaint_type, descriptor, status,
    borough, city, incident_zip, incident_address,
    latitude, longitude, location_type,
    open_data_channel_type,
    resolution_description
  )
saveRDS(df_clean_final, "df_clean_final.rds")
```

```{r}
combined0 <- combined |>
  mutate(
    across(where(is.character), \(x) str_squish(x)),
    across(where(is.character), \(x) na_if(x, ""))
  )

miss_by_col_all <- combined0 |>
  summarise(across(everything(), \(x) sum(is.na(x)))) |>
  pivot_longer(everything(), names_to = "column", values_to = "missing_n") |>
  mutate(total_n = nrow(combined0),
         missing_rate = missing_n / total_n) |>
  arrange(desc(missing_n))
```

```{r}
uniq_by_col <- combined0 |>
  summarise(across(where(is.character), \(x) n_distinct(x, na.rm = TRUE))) |>
  pivot_longer(everything(), names_to = "column", values_to = "unique_n") |>
  arrange(desc(unique_n))

top_uniq <- uniq_by_col |>
  slice_max(unique_n, n = 25)

ggplot(top_uniq, aes(x = reorder(column, unique_n), y = unique_n)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Top character columns by number of unique values (pre-selection)",
    x = NULL,
    y = "Number of unique values"
  )
```

```{r}
library(dplyr)
library(stringr)
library(lubridate)

df0 <- df_clean |>
  mutate(
    across(where(is.character), \(x) str_squish(x)),
    across(where(is.character), \(x) na_if(x, "")),
    across(where(is.character), \(x) na_if(x, "NA")),
    across(where(is.character), \(x) na_if(x, "N/A"))
  )
```


```{r}
library(redav)
critical_cols <- c("location_type", "complaint_type", "borough")

plot_missing(df0[critical_cols])


```

```{r}
library(dplyr)
library(ggplot2)
library(scales)

# 1. Compute geolocation validity
geo_check <- df0 |>
  transmute(
    latitude = suppressWarnings(as.numeric(latitude)),
    longitude = suppressWarnings(as.numeric(longitude)),
    geo_ok = !is.na(latitude) & !is.na(longitude) &
      between(latitude, 40, 41.2) &
      between(longitude, -74.5, -73.2)
  )

# 2. Prepare summary for % view
geo_summary <- geo_check |>
  count(geo_ok) |>
  mutate(
    label = ifelse(geo_ok, "Valid NYC Coordinates", "Invalid / Missing Coordinates"),
    pct = n / sum(n)
  )

# 3. Plot
ggplot(geo_summary, aes(x = label, y = pct, fill = label)) +
  geom_col(width = 0.6, alpha = 0.85) +
  geom_text(aes(label = percent(pct, accuracy = 0.1)),
            vjust = -0.5, size = 5) +
  scale_y_continuous(labels = percent_format(accuracy = 1),
                     expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c("#1b9e77", "#d95f02")) +
  labs(
    title = "Geolocation Validity of 311 Records",
    subtitle = "Latitude–longitude checked against the NYC bounding box",
    x = NULL,
    y = "% of Records",
    fill = NULL
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold")
  )

```

```{r}
library(dplyr)
library(ggplot2)
library(scales)

df_zip <- df_clean_final |>
  mutate(
    zip_num = suppressWarnings(as.numeric(incident_zip)),
    zip_category = case_when(
      is.na(zip_num) ~ "Missing ZIP",
      zip_num >= 10000 & zip_num <= 11697 ~ "Valid NYC ZIP",
      TRUE ~ "Invalid ZIP"
    )
  ) |>
  count(zip_category) |>
  mutate(
    percent = n / sum(n),
    label = paste0(comma(n), " (", percent_format(accuracy = 0.1)(percent), ")")
  )

ggplot(df_zip, aes(x = reorder(zip_category, -n), y = n, fill = zip_category)) +
  geom_col(width = 0.6) +
  
  # FIX: always place labels *just above* bars safely
  geom_text(
    aes(label = label),
    vjust = -0.8,   # pull upward slightly
    size = 5,
    fontface = "bold"
  ) +
  
  scale_fill_manual(values = c(
    "Valid NYC ZIP" = "#1b9e77",
    "Invalid ZIP"   = "#d95f02",
    "Missing ZIP"   = "#7570b3"
  )) +
  
  # FIX: expand limits so labels never get clipped or flipped
  scale_y_continuous(
    labels = comma,
    expand = expansion(mult = c(0, 0.15))  # extra 15% space above
  ) +
  
  labs(
    title = "ZIP Code Quality Summary",
    subtitle = "Distribution of valid, invalid, and missing ZIP codes",
    x = NULL,
    y = "Number of Records"
  ) +
  
  theme_minimal(base_size = 15) +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold", size = 18),
    plot.subtitle = element_text(size = 13)
  )

df_clean <- df_clean_final %>%
  mutate(
    zip_num = suppressWarnings(as.numeric(incident_zip))
  ) %>%
  filter(
    !is.na(zip_num),
    zip_num >= 10000,
    zip_num <= 11697
  ) %>%
  select(-zip_num)


```
```{r}

library(dplyr)
library(ggplot2)
library(scales)

df_boro_dist <- df_clean_final %>%
  count(borough) %>%
  mutate(
    percent = n / sum(n),
    label = paste0(comma(n), "\n(", percent_format(accuracy = 0.1)(percent), ")")
  )

ggplot(df_boro_dist, aes(x = reorder(borough, -n), y = n, fill = borough)) +
  geom_col(width = 0.7) +

  # Label BELOW bar → absolutely zero overlap
  geom_text(
    aes(label = label),
    vjust = 1.3,
    size = 4,
    color = "black"
  ) +

  scale_y_continuous(labels = comma) +
  scale_fill_brewer(palette = "Set2") +

  labs(
    title = "Record Distribution Across NYC Boroughs",
    subtitle = "After removing invalid or missing borough entries",
    x = NULL,
    y = "Number of Records"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold"),
    axis.text.x = element_text(face = "bold")
  )
df_clean_final <- df_clean_final %>% 
  filter(borough %in% valid_boros)

```



