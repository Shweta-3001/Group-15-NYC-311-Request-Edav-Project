[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NYC 311 Service Requests Analysis",
    "section": "",
    "text": "1 1. Introduction\nNew York City operates on an immense scale, like millions of residents who depend daily on public services which keeps the city running. With such a complex infrastructure mistakes are bound to happen. The 311 service request system serves as the city’s non-emergency channel, capturing how residents experience and report those issues. Each ticket, call, or update represents a snapshot of the city’s response in real time.\nThe motivation for this project came from simple question: What can 311 data reveal about how New Yorkers interact with their city? We aimed to discover patterns in complaint behavior, agency response, identifying which issues dominate, how quickly they are resolved, and where lack of efficiency is there across boroughs and complaint types.\nFew guiding questions shaped our exploration: 1. What are New Yorkers worried about?\nHow do the types of complaints differ by location (e.g., borough, location type) and by reporting channel (phone, online, mobile)?\n\nHow do complaints get handled from start to finish?\nWhat does the journey look like from the time a complaint is created until it is closed, and how do status and resolution patterns vary across complaint types and agencies?\nHow busy is the system, and where are the main slowdowns?\nWhen is the 311 system under the most pressure, and how do backlog and resolution times reveal operational bottlenecks?\n\nUsing raw data from the NYC Open Data Portal, we started with:\n\nData cleaning and standardization: corrected invalid timestamps, merged redundant categories, and ensured consistency across key fields.\n\nFeature engineering: created measures like complaint bucket, resolution time and service age to quantify responses.\n\nGeospatial enrichment: integrated boroughs, neighborhoods, and agencies to study spatial variation.\n\nSystem exploration: we filed a sample noise complaint ourselves to observe how user inputs and follow-up actions in the 311 system are recorded as structured fields in the dataset.\n\nThrough this process, our analysis started from raw records into a clear picture of 311 service interaction. It highlights how most requests are handled promptly while certain complaint categories show persistent delays demonstrating how open data can transform everyday service calls into measurable insights on life in New York City.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>1. Introduction</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "2  Data",
    "section": "",
    "text": "2.1 Data Source and Scope\nNew York City’s 311 system is how, residents let the city know about issues in their communities, such as noise, heating problems, trash, and illegal parking etc. Each entry in the 311 data represents a moment when someone was concerned enough to reach out to the city for assistance.\nThe raw data come from the NYC Open Data 311 service request API. To avoid time-outs and memory issues, we chose to download the data month-by-month, combined, and then saved as an .rds file for efficient reuse. In total, the working dataset contains around 6M over a two-year window, from early 2023 through late 2024.\nCode\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(stringr)\nlibrary(memoise)\nCode\n# library(RSocrata)\n# library(dplyr)\n\n# options(timeout = 600)\n\n# base_url &lt;- \"https://data.cityofnewyork.us/resource/erm2-nwe9.json\"\n\n# get_month_data &lt;- function(year, month) {\n#   start &lt;- sprintf(\"%d-%02d-01T00:00:00\", year, month)\n#   # end = first day of next month\n#   if (month == 12) {\n#     end &lt;- sprintf(\"%d-01-01T00:00:00\", year + 1)\n#   } else {\n#     end &lt;- sprintf(\"%d-%02d-01T00:00:00\", year, month + 1)\n#   }\n\n#   url &lt;- sprintf(\n#     \"%s?$where=created_date &gt;= '%s' AND created_date &lt; '%s'\",\n#     base_url, start, end\n#   )\n#   message(\"Fetching: \", start, \" to \", end)\n#   read.socrata(url)\n# }\n\n# # Example: all months of 2023\n# months &lt;- 1:12\n# list_2023 &lt;- lapply(months, function(m) get_month_data(2023, m))\n# data_2023 &lt;- bind_rows(list_2023)\n# list_2024 &lt;- lapply(months, function(m) get_month_data(2024, m))\n# data_2024 &lt;- bind_rows(list_2024)\n# combined &lt;- rbind(data_2023,data_2024)\n# saveRDS(combined, \"nyc_311_data.rds\")\nCode\ncombined=combined &lt;- readRDS(\"nyc_311_data.rds\")\n#combined=combined &lt;- readRDS(\"nyc_311_data.rds\")\nEach row corresponds to a single 311 complaint and includes the following groups of variables:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#data-source-and-scope",
    "href": "data.html#data-source-and-scope",
    "title": "2  Data",
    "section": "",
    "text": "2.1.1 Timestamps\n\ncreated_date: when the complaint was submitted\n\nclosed_date: when the complaint was closed (if ever)\n\nresolution_action_updated_date: when a resolution action was logged\n\n\n\n2.1.2 Categorical Descriptors\n\nagency, agency_name\n\ncomplaint_type and a higher-level complaint_bucket (custom grouping)\n\ndescriptor (more detailed description of the issue)\n\nstatus (e.g., \"Closed\", \"Assigned\", \"In Progress\")\n\n\n\n2.1.3 Location Information\n\nborough, incident_zip, incident_address\n\nlocation_type (e.g., \"RESIDENTIAL BUILDING\", \"Street/Sidewalk\")\n\nlatitude, longitude\n\n\n\n2.1.4 Channel and Resolution\n\nopen_data_channel_type (e.g., ONLINE, PHONE, MOBILE, OTHER)\n\nresolution_description and resolution_action fields",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#data-quality-missingness-across-columns",
    "href": "data.html#data-quality-missingness-across-columns",
    "title": "2  Data",
    "section": "2.2 Data Quality: Missingness Across Columns",
    "text": "2.2 Data Quality: Missingness Across Columns\nBefore doing any substantive analysis, we examined the completeness of the raw 311 dataset. The goal of this step was to understand which variables are reliable, which ones are mostly empty, and where cleaning or dropping variables is justified.\n\n\nCode\nmissing_values_summary &lt;- colSums(is.na(combined))\nmissing_columns &lt;- missing_values_summary[missing_values_summary &gt; 0]\nmissing_table &lt;- data.frame(\n  Column = names(missing_columns),\n  MissingCount = as.numeric(missing_columns)\n)\nsorted_table &lt;- missing_table |&gt;\narrange(desc(MissingCount))\nprint(sorted_table)\n\n\n                           Column MissingCount\n1            taxi_company_borough      6679852\n2                       road_ramp      6668175\n3        bridge_highway_direction      6660223\n4                        due_date      6651779\n5             bridge_highway_name      6639447\n6          bridge_highway_segment      6639437\n7           taxi_pick_up_location      6611318\n8                    vehicle_type      6504338\n9                   facility_type      6199357\n10                       landmark      2652950\n11          intersection_street_1      2180001\n12          intersection_street_2      2176719\n13                 cross_street_1      1903203\n14                 cross_street_2      1902070\n15                  location_type       800974\n16                            bbl       752073\n17                           city       325436\n18                    street_name       244008\n19               incident_address       243812\n20                    closed_date       133656\n21                       latitude       102706\n22                      longitude       102706\n23              location.latitude       102706\n24             location.longitude       102706\n25         location.human_address       102706\n26       x_coordinate_state_plane       102597\n27       y_coordinate_state_plane       101804\n28         resolution_description        93259\n29                     descriptor        78842\n30                   incident_zip        72906\n31 resolution_action_updated_date        37625\n32                   address_type        30391\n33                   created_date            1\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n# 1) Compute missingness per column\nmiss_by_col_all &lt;- combined |&gt;\n  summarise(across(everything(), \\(x) sum(is.na(x)))) |&gt;\n  pivot_longer(everything(), names_to = \"column\", values_to = \"missing_n\") |&gt;\n  mutate(\n    total_n      = nrow(combined),\n    missing_rate = missing_n / total_n\n  ) |&gt;\n  arrange(desc(missing_n))\n\n# 2) Top 25 columns by missing rate, add index label\ntop_missing_rate &lt;- miss_by_col_all |&gt;\n  slice_max(missing_rate, n = 25) |&gt;\n  arrange(desc(missing_rate)) |&gt;\n  mutate(\n    rank_label = paste0(row_number(), \". \", column),\n    rank_label = factor(rank_label, levels = rev(rank_label))  # for coord_flip\n  )\n\n# 3) Nice bar plot\np_missing &lt;- ggplot(top_missing_rate,\n                    aes(x = rank_label, y = missing_rate, fill = missing_rate)) +\n  geom_col(width = 0.8) +\n  coord_flip() +\n  scale_y_continuous(\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_fill_viridis_c(\n    option = \"C\",\n    direction = -1,\n    name = \"Missing rate\"\n  ) +\n  labs(\n    title = \"Top Columns by Missingness Rate\",\n    x = \"Features\",\n    y = \"Missingness rate\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    panel.grid.minor = element_blank(),\n    axis.text.y  = element_text(size = 9),\n    axis.text.x  = element_text(size = 10),\n    plot.title   = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(size = 11),\n    legend.position = \"right\"\n  )\n\np_missing\n\n\n\n\n\n\n\n\n\nCode\n# 4) Threshold + list of columns to drop (same logic as before)\nmissing_threshold &lt;- 0.60\n\ncols_to_drop_by_missing &lt;- miss_by_col_all |&gt;\n  filter(missing_rate &gt; missing_threshold) |&gt;\n  pull(column)\n\n\nThe first plot shows the 25 columns with the highest proportion of missing values. Each bar is a column, ordered from most to least missing, and the color scale encodes the missingness rate.\nKey observations:\n\nSeveral columns have almost complete missingness (≈ 95–100%), including\ntaxi_company_borough, road_ramp, bridge_highway_direction, bridge_highway_name,\nbridge_highway_segment, and taxi_pick_up_location.\nMany of these fields are highly specialized (e.g., taxi or bridge/highway metadata) that apply only to a very small subset of 311 requests.\nA second tier of columns (e.g., intersection_street_1, intersection_street_2, cross_street_1, cross_street_2) has moderate missingness (roughly 25–40%), typically for records where complaints do not occur at an intersection. We decided to remove extreme missingness columns from final dataframe, which will add noise and complexity without contributing to the main objective of the project and columns with moderate missingness but high potential value were kept for further analysis.\n\n\n\nCode\nset.seed(42)\nsampled_data &lt;- combined[sample(1:nrow(combined), 5000), ]\n\nmissing_long &lt;- as.data.frame(is.na(sampled_data)) |&gt;\n  pivot_longer(cols = everything(), names_to = \"Column\", values_to = \"IsMissing\")\n\nmissing_long &lt;- cbind(RowIndex = rep(1:nrow(sampled_data), times = ncol(sampled_data)), missing_long)\n\n# Plotting heatmap of missing data\nggplot(missing_long, aes(x = Column, y = RowIndex, fill = IsMissing)) +\n  geom_tile() +\n  scale_fill_manual(values = c(\"FALSE\" = \"white\", \"TRUE\" = \"red\"), name = \"Missing\") +\n  labs(title = \"Heatmap of Missing Data (Sampled Rows)\",\n       x = \"Columns\",\n       y = \"Row Index\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n\n\n\n\n\n\n\n\nTo complement the summary bar chart, we also visualized missingness row by row for a random sample of records. In this heatmap:\n\nSome columns form solid vertical red bands, meaning they are missing for almost all rows which correspond to the heavily missing taxi/bridge fields seen in the previous plot.\nOther columns show stripe-like patterns, where only some rows are missing (e.g., closed_date for still-open complaints).\nCore analytical fields such as created_date, complaint_type, and borough appear almost entirely white, confirming that they are reliable.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#focusing-on-key-categorical-variables",
    "href": "data.html#focusing-on-key-categorical-variables",
    "title": "2  Data",
    "section": "2.3 Focusing on Key Categorical Variables",
    "text": "2.3 Focusing on Key Categorical Variables\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n\n# Borough counts on cleaned data\nborough_counts &lt;- combined |&gt;\n  count(borough, name = \"n\") |&gt;\n  mutate(\n    share = n / sum(n),\n    label_text = paste0(comma(n), \" (\", percent(share, accuracy = 0.05), \")\")\n  ) |&gt;\n  arrange(desc(n))\n\nggplot(borough_counts,\n       aes(x = reorder(borough, n), y = n)) +\n  geom_col(width = 0.7, fill = \"#1b9e77\") +\n  geom_text(aes(label = label_text), vjust = -0.5, size = 4) +\n  scale_y_continuous(\n    labels = scales::comma,\n    breaks = scales::pretty_breaks(n = 8),\n    expand = expansion(mult = c(0, 0.15))\n  ) +\n  labs(\n    title = \"Borough Distribution of 311 Complaints\",\n    x = \"NYC Borough\",\n    y = \"Number of complaints\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    panel.grid.minor = element_blank(),\n    axis.text.y  = element_text(size = 10),\n    axis.text.x  = element_text(size = 10),\n    plot.title   = element_text(face = \"bold\", size = 16),\n    plot.subtitle = element_text(size = 11),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n\nInterpretation:\n-Unspecified boroughs ~ 8000 complaints (0.1%) were excluded in final data. - Brooklyn and Queens together account for more than half of all 311 complaints, which is broadly consistent with their larger populations and geographic size. - Staten Island contributes a comparatively small share of complaints (3.7%), reflecting both its smaller population and possibly different usage patterns of 311.\nThis plot acts as a sanity check that the dataset reflects known patterns of NYC population and service use and also it provides context for later plots that break down complaint types and system performance within each borough.\nMissingness Pattern for Core Categorical Variables\n\n\nCode\n#label\nvalid_boros &lt;- c(\"MANHATTAN\", \"BROOKLYN\", \"QUEENS\", \"BRONX\", \"STATEN ISLAND\")\n\ndf_clean_final &lt;- combined |&gt;\n  filter(borough %in% valid_boros)\n\ndf_clean_final &lt;- df_clean_final |&gt;\n  dplyr::select(\n    unique_key, created_date, closed_date, resolution_action_updated_date,\n    agency, agency_name, complaint_type, descriptor, status,\n    borough, city, incident_zip, incident_address,\n    latitude, longitude, location_type,\n    open_data_channel_type,\n    resolution_description\n  )\n#saveRDS(df_clean_final, \"df_clean_final.rds\")\n\n\n\n\nCode\ncombined0 &lt;- combined |&gt;\n  mutate(\n    across(where(is.character), \\(x) str_squish(x)),\n    across(where(is.character), \\(x) na_if(x, \"\"))\n  )\n\nmiss_by_col_all &lt;- combined0 |&gt;\n  summarise(across(everything(), \\(x) sum(is.na(x)))) |&gt;\n  pivot_longer(everything(), names_to = \"column\", values_to = \"missing_n\") |&gt;\n  mutate(total_n = nrow(combined0),\n         missing_rate = missing_n / total_n) |&gt;\n  arrange(desc(missing_n))\n\n\n\n\nCode\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(lubridate)\n\ndf0 &lt;- df_clean_final |&gt;\n  mutate(\n    across(where(is.character), \\(x) str_squish(x)),\n    across(where(is.character), \\(x) na_if(x, \"\")),\n    across(where(is.character), \\(x) na_if(x, \"NA\")),\n    across(where(is.character), \\(x) na_if(x, \"N/A\"))\n  )\n\n\n\n\nCode\nlibrary(redav)\ncritical_cols &lt;- c(\"location_type\", \"complaint_type\", \"borough\")\nplot_missing(df0[critical_cols])\n\n\n\n\n\n\n\n\n\nMain findings:\n\nborough and complaint_type are essentially complete almost no records are missing these fields.\nlocation_type has a small but noticeable amount of missingness (around 10–15% of rows). The plot shows two main patterns:\n\nComplete cases (all three variables present).\n\nCases where only location_type is missing.\n\nFor analyses that depend heavily on location_type (e.g., location-type heatmaps and action distributions), we restrict to complete cases so that percentages are meaningful.\nFor other analyses, we kept \"Unknown\" or NA category for location_type, so that rows are not discarded unnecessarily.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#spatial-data-quality-checks",
    "href": "data.html#spatial-data-quality-checks",
    "title": "2  Data",
    "section": "2.4 Spatial Data Quality Checks",
    "text": "2.4 Spatial Data Quality Checks\nMany of the most interesting 311 questions are spatial (Which neighborhoods complain the most? Where are issues slowest to resolve?), so we checked the quality of the geographic fields before using them.\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n# 1. Compute geolocation validity\ngeo_check &lt;- df0 |&gt;\n  transmute(\n    latitude = suppressWarnings(as.numeric(latitude)),\n    longitude = suppressWarnings(as.numeric(longitude)),\n    geo_ok = !is.na(latitude) & !is.na(longitude) &\n      between(latitude, 40, 41.2) &\n      between(longitude, -74.5, -73.2)\n  )\n\n# 2. Prepare summary for % view\ngeo_summary &lt;- geo_check |&gt;\n  count(geo_ok) |&gt;\n  mutate(\n    label = ifelse(geo_ok, \"Valid NYC Coordinates\", \"Invalid / Missing Coordinates\"),\n    pct = n / sum(n)\n  )\n\n# 3. Plot\nggplot(geo_summary, aes(x = label, y = pct, fill = label)) +\n  geom_col(width = 0.6, alpha = 0.85) +\n  geom_text(aes(label = percent(pct, accuracy = 0.1)),\n            vjust = -0.5, size = 5) +\n  scale_y_continuous(labels = percent_format(accuracy = 1),\n                     expand = expansion(mult = c(0, 0.1))) +\n  scale_fill_manual(values = c(\"#1b9e77\", \"#d95f02\")) +\n  labs(\n    title = \"Geolocation Validity of 311 Records\",\n    x = \"Geolocation Status\",\n    y = \"% of Records\",\n    fill = NULL\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\nThe bar chart shows:\n\n98.5% of records have valid latitude–longitude pairs.Only 1.5% are invalid or missing.\n\nWhen making maps or location summaries, we’ll only use the valid coordinate subset. This prevented us from plotting points that are clearly wrong (like locations outside of NYC or at (0, 0)).\n\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\ndf_zip &lt;- df_clean_final |&gt;\n  mutate(\n    zip_num = suppressWarnings(as.numeric(incident_zip)),\n    zip_category = case_when(\n      is.na(zip_num) ~ \"Missing ZIP\",\n      zip_num &gt;= 10000 & zip_num &lt;= 11697 ~ \"Valid NYC ZIP\",\n      TRUE ~ \"Invalid ZIP\"\n    )\n  ) |&gt;\n  count(zip_category) |&gt;\n  mutate(\n    percent = n / sum(n),\n    label = paste0(comma(n), \" (\", percent_format(accuracy = 0.1)(percent), \")\")\n  )\n\nggplot(df_zip, aes(x = reorder(zip_category, -n), y = n, fill = zip_category)) +\n  geom_col(width = 0.6) +\n  \n  # FIX: always place labels *just above* bars safely\n  geom_text(\n    aes(label = label),\n    vjust = -0.8,   # pull upward slightly\n    size = 5,\n    fontface = \"bold\"\n  ) +\n  \n  scale_fill_manual(values = c(\n    \"Valid NYC ZIP\" = \"#1b9e77\",\n    \"Invalid ZIP\"   = \"#d95f02\",\n    \"Missing ZIP\"   = \"#7570b3\"\n  )) +\n  \n  # FIX: expand limits so labels never get clipped or flipped\n  scale_y_continuous(\n    labels = comma,\n    expand = expansion(mult = c(0, 0.15))  # extra 15% space above\n  ) +\n  \n  labs(\n    title = \"ZIP Code Quality Summary\",\n    x = \"Zip Code Category\",\n    y = \"Number of Records\"\n  ) +\n  \n  theme_minimal(base_size = 13) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(face = \"bold\", size = 18)\n  )\n\n\n\n\n\n\n\n\n\nCode\ndf_clean &lt;- df_clean_final %&gt;%\n  mutate(\n    zip_num = suppressWarnings(as.numeric(incident_zip))\n  ) %&gt;%\n  filter(\n    !is.na(zip_num),\n    zip_num &gt;= 10000,\n    zip_num &lt;= 11697\n  ) %&gt;%\n  select(-zip_num)\n\n\nPerforming a similar quality check for ZIP codes by comparing each incident_zip to a list of valid NYC ZIP codes and allowing for missing values.\nCleaning decision.\n\nRecords with invalid ZIPs were treated as data errors and effectively ignored in ZIP-level summaries.\nRecords with missing ZIPs were kept in the main dataset but excluded from analyses that group by ZIP code.\n\nOverall, both latitude–longitude and ZIP quality checks suggest that spatial information in the dataset is highly reliable, with only a small fraction of problematic records.\n\n\n\nCode\nsaveRDS(df_clean_final, \"df_clean_final.rds\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "3  Results",
    "section": "",
    "text": "3.1 How many complaints are received over time? Which months are the busiest?\nThis section walks through what we actually see in the 311 data.\nInstead of repeating every statistic, we use set of plots where each one is meant to answer a specific question. For each figure, we describe:\nCode\ndf_clean_final &lt;- readRDS(\"df_clean_final.rds\")\ncomplaints &lt;- df_clean_final |&gt;\n  mutate(\n    year = year(created_date),\n    month = month(created_date, label = TRUE, abbr = TRUE),  # Jan, Feb, etc.\n    month_num = month(created_date),  # 1, 2, 3, etc.\n    year_month = floor_date(created_date, \"month\")  # First day of each month\n  )\ncomplaints_summary &lt;- complaints |&gt;\n  filter(!is.na(year)) |&gt;    \n  group_by(year, month, month_num) |&gt;\n  summarise(total_complaints = n(), .groups = \"drop\") |&gt;\n  arrange(year, month_num)\n\n\nplot3 &lt;- ggplot(complaints_summary, \n                aes(x = month_num, y = total_complaints, \n                    color = factor(year), group = year)) +\n  geom_line(size = 1.2) +\n  geom_point(size = 3) +\n  scale_x_continuous(breaks = 1:12, labels = month.abb) +\n  scale_y_continuous(\n    limits = c(220000, 320000),\n    breaks = seq(220000, 320000, by = 10000),\n    labels = scales::comma\n  ) +\n  scale_color_brewer(palette = \"Dark2\", name = \"Year\") +\n  labs(\n    title = \"Complaint Trends Across Months\",\n    x = \"Month\",\n    y = \"Total Complaints\"\n  ) +\n  theme_report()\nprint(plot3)\nObservations:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#how-many-complaints-are-received-over-time-which-months-are-the-busiest",
    "href": "results.html#how-many-complaints-are-received-over-time-which-months-are-the-busiest",
    "title": "3  Results",
    "section": "",
    "text": "February sees the lowest volume of complaints in both years.\nThe months of June, September , December in 2024 see the highest volume of complaints.\nOpposite trend is observed in 2023 where May, July, October see the highest volume of complaints.\nThere is no clear seasonal pattern across the two years, suggesting that complaint volume is influenced by factors other than just time of year.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#which-complaint-types-are-most-common-in-nyc",
    "href": "results.html#which-complaint-types-are-most-common-in-nyc",
    "title": "3  Results",
    "section": "3.2 Which complaint types are most common in NYC?",
    "text": "3.2 Which complaint types are most common in NYC?\nThere were a unique total of 300 complaint types reported in the dataset. The complaint were bucketed into the following categories for better analysis: Noise Related, Heat/Water/Gas Issues, Buildings and Housing, Sanitation and Waste, Street and Traffic Conditions, Public Safety / Crime / Quality of Life, Vehicle and Parking, Utilities and Power, Pests and Animals, Others / Miscellaneous.\n\n\nCode\ncomplaint_category_mapping &lt;- list(\n  \"Noise Related\" = c(\n    \"Noise - Residential\", \"Noise - Street/Sidewalk\", \"Noise - Commercial\",\n    \"Noise\", \"Noise - Vehicle\", \"Noise - Helicopter\", \"Noise - Park\",\n    \"Noise - House of Worship\"\n  ),\n  \n  \"Heat/Water/Gas Issues\" = c(\n    \"HEAT/HOT WATER\", \"Water System\", \"WATER LEAK\", \"PLUMBING\",\n    \"Water Leak\", \"Drinking Water\", \"Water Quality\", \"Water Maintenance\",\n    \"Water Drainage\", \"Drinking Water General\", \"Drinking Water Tank\",\n    \"Drinking Water Conservation\", \"Bottled Water\", \"DEP Sidewalk Condition\",\n    \"Non-Residential Heat\", \"Heat/Hot Water\"\n  ),\n  \n  \"Buildings and Housing\" = c(\n    \"PAINT/PLASTER\", \"DOOR/WINDOW\", \"FLOORING/STAIRS\", \"APPLIANCE\",\n    \"Elevator\", \"Lead\", \"SAFETY\", \"Indoor Air Quality\", \"Plumbing\",\n    \"Boilers\", \"Electrical\", \"ELEVATOR\", \"Asbestos\", \"Paint/Plaster\",\n    \"Door/Window\", \"OUTSIDE BUILDING\", \"Wood Pile\", \"Mold\",\n    \"Flooring/Stairs\", \"Appliance\", \"Scaffold Safety\", \"Electric\",\n    \"Unstable Building\", \"Window Guard\", \"Cooling Tower\", \"Peeling Paint\",\n    \"Facade Insp Safety Pgm\", \"Outside Building\"\n  ),\n  \n  \"Sanitation and Waste\" = c(\n    \"UNSANITARY CONDITION\", \"Dirty Condition\", \"Missed Collection\",\n    \"Residential Disposal Complaint\", \"Litter Basket Request\",\n    \"Commercial Disposal Complaint\", \"Litter Basket Complaint\",\n    \"Sanitation Worker or Vehicle Complaint\", \"Dumpster Complaint\",\n    \"Industrial Waste\", \"Seasonal Collection\", \"Institution Disposal Complaint\",\n    \"Transfer Station Complaint\", \"DSNY Internal\"\n  ),\n  \n  \"Street and Traffic Conditions\" = c(\n    \"Street Condition\", \"Traffic Signal Condition\", \"Street Light Condition\",\n    \"Sidewalk Condition\", \"Curb Condition\", \"Street Sign - Damaged\",\n    \"Street Sign - Missing\", \"Street Sign - Dangling\", \"Highway Condition\",\n    \"Highway Sign - Damaged\", \"Highway Sign - Missing\", \"Highway Sign - Dangling\",\n    \"Bridge Condition\", \"Tunnel Condition\", \"DEP Highway Condition\",\n    \"DEP Street Condition\"\n  ),\n  \n  \"Public Safety / Crime / Quality of Life\" = c(\n    \"Homeless Person Assistance\", \"Encampment\", \"Non-Emergency Police Matter\",\n    \"Drug Activity\", \"Graffiti\", \"Illegal Fireworks\", \"Panhandling\",\n    \"Animal-Abuse\", \"Violation of Park Rules\", \"Illegal Posting\",\n    \"Hazardous Materials\", \"Smoking\", \"Unleashed Dog\", \"Urinating in Public\",\n    \"Disorderly Youth\", \"Squeegee\", \"Quality of Life\", \"Face Covering Violation\"\n  ),\n  \n  \"Vehicle and Parking\" = c(\n    \"Illegal Parking\", \"Blocked Driveway\", \"Abandoned Vehicle\",\n    \"Derelict Vehicles\", \"Broken Parking Meter\", \"Municipal Parking Facility\"\n  ),\n  \n  \"Utilities and Power\" = c(\n    \"ELECTRIC\", \"Sewer\", \"Root/Sewer/Sidewalk Condition\", \"Radioactive Material\",\n    \"X-Ray Machine/Equipment\", \"Oil or Gas Spill\"\n  ),\n  \n  \"Pests and Animals\" = c(\n    \"Rodent\", \"Animal in a Park\", \"Unsanitary Pigeon Condition\",\n    \"Harboring Bees/Wasps\", \"Illegal Animal Kept as Pet\", \"Mosquitoes\",\n    \"Pet Shop\", \"Poison Ivy\", \"Illegal Animal Sold\", \"Unsanitary Animal Facility\",\n    \"Animal Facility - No Permit\", \"Unlicensed Dog\", \"Unsanitary Animal Pvt Property\"\n  ),\n  \n  \"Others / Miscellaneous\" = c(\n    \"General Construction/Plumbing\", \"Illegal Dumping\", \"GENERAL\",\n    \"Damaged Tree\", \"Maintenance or Facility\", \"New Tree Request\",\n    \"For Hire Vehicle Complaint\", \"Overgrown Tree/Branches\", \"Consumer Complaint\",\n    \"Vendor Enforcement\", \"Building/Use\", \"Obstruction\", \"Air Quality\",\n    \"Dead/Dying Tree\", \"Dead Animal\", \"Street Sweeping Complaint\",\n    \"Taxi Complaint\", \"Lost Property\", \"Outdoor Dining\",\n    \"Real Time Enforcement\", \"Mobile Food Vendor\", \"Bike/Roller/Skate\",\n    \"Chronic\", \"Special Projects Inspection Team (SPIT)\", \"Illegal Tree Damage\",\n    \"Electronics Waste Appointment\", \"Emergency Response Team (ERT)\",\n    \"Food Poisoning\", \"Smoking or Vaping\", \"Day Care\", \"Standing Water\",\n    \"Investigations and Discipline (IAD)\", \"Remaining Taxi Report\",\n    \"E-Scooter\", \"BEST/Site Safety\", \"Indoor Sewage\", \"For Hire Vehicle Report\",\n    \"Uprooted Stump\", \"Green Taxi Complaint\", \"Ferry Inquiry\", \"Ferry Complaint\",\n    \"Beach/Pool/Sauna Complaint\", \"Tattooing\", \"Plant\", \"Bus Stop Shelter Placement\",\n    \"LinkNYC\", \"Bus Stop Shelter Complaint\", \"Posting Advertisement\",\n    \"Taxi Compliment\", \"AHV Inspection Unit\", \"Adopt-A-Basket\",\n    \"Cranes and Derricks\", \"Recycling Basket Complaint\", \"Found Property\",\n    \"Incorrect Data\", \"Bike Rack\", \"Special Natural Area District (SNAD)\",\n    \"Public Toilet\", \"Dept of Investigations\", \"Lifeguard\", \"Special Operations\",\n    \"Dispatched Taxi Complaint\", \"Boiler\", \"Bench\", \"Building Condition\",\n    \"Taxi Licensee Complaint\", \"Retailer Complaint\", \"Calorie Labeling\",\n    \"ZTESTINT\", \"Public Payphone Complaint\", \"FHV Licensee Complaint\",\n    \"Wayfinding SNW\", \"Leaning\", \"Bar\", \"Building Marshal's Office\",\n    \"Building Marshals office\", \"DOB Posted Notice or Order\",\n    \"Construction Safety Enforcement\", \"Tanning\", \"Executive Inspections\",\n    \"Internal\", \"Code\", \"Private School\", \"Vaccine Mandate Non-Compliance\",\n    \"Dispatched Taxi Compliment\", \"SRDE\", \"Stalled Sites\",\n    \"Sustainability Enforcement\", \"Trans Fat\", \"Food Establishment\",\n    \"Sewer Maintenance\", \"Bike Rack Condition\", \"Construction Lead Dust\"\n  )\n)\n\n# Create a long-format data frame\ncomplaint_mapping_df &lt;- data.frame(\n  complaint_type = unlist(complaint_category_mapping),\n  category = rep(names(complaint_category_mapping), \n                 sapply(complaint_category_mapping, length)),\n  stringsAsFactors = FALSE\n)\nrownames(complaint_mapping_df) &lt;- NULL\nmap_complaint_to_category &lt;- function(complaint_type) {\n  for (category in names(complaint_category_mapping)) {\n    if (complaint_type %in% complaint_category_mapping[[category]]) {\n      return(category)\n    }\n  }\n  return(\"Others / Miscellaneous\")\n}\n\n# Apply the mapping to create complaint_bucket column\ndf_clean_final &lt;- df_clean_final |&gt;\n  mutate(complaint_bucket = sapply(complaint_type, map_complaint_to_category))\n\ncomplaint_bucket_counts &lt;- df_clean_final |&gt;\n  count(complaint_bucket, sort = TRUE)\n\ncomplaint_bucket_borough &lt;- df_clean_final |&gt;\n  group_by(borough, complaint_bucket) |&gt;\n  summarise(count = n(), .groups = \"drop\") |&gt;\n  group_by(borough) |&gt;\n  mutate(\n    total_borough = sum(count),\n    proportion = count / total_borough * 100\n  ) |&gt;\n  ungroup()\nprint(complaint_bucket_borough)\n\n\n# A tibble: 50 × 5\n   borough complaint_bucket                       count total_borough proportion\n   &lt;chr&gt;   &lt;chr&gt;                                  &lt;int&gt;         &lt;int&gt;      &lt;dbl&gt;\n 1 BRONX   Buildings and Housing                 152187       1365908      11.1 \n 2 BRONX   Heat/Water/Gas Issues                 280270       1365908      20.5 \n 3 BRONX   Noise Related                         354903       1365908      26.0 \n 4 BRONX   Others / Miscellaneous                105631       1365908       7.73\n 5 BRONX   Pests and Animals                      14932       1365908       1.09\n 6 BRONX   Public Safety / Crime / Quality of L…  32185       1365908       2.36\n 7 BRONX   Sanitation and Waste                  107341       1365908       7.86\n 8 BRONX   Street and Traffic Conditions          49349       1365908       3.61\n 9 BRONX   Utilities and Power                    28127       1365908       2.06\n10 BRONX   Vehicle and Parking                   240983       1365908      17.6 \n# ℹ 40 more rows\n\n\nTo see how concerns differ across boroughs, we turned these counts into within-borough percentages and plotted them as a Cleveland dot plot, faceted by borough.\n\n\nCode\n# prepare plot data: percent label and reorder within each borough\n\nplot_df &lt;- complaint_bucket_borough |&gt;\n  mutate(prop_label = paste0(round(proportion, 1), \"%\"),\n         complaint_bucket = reorder_within(complaint_bucket, proportion, borough, fun = max))\n\n# Cleveland dot-plot showing proportion (%) and ordered by highest per borough\nggplot(plot_df, aes(x = proportion, y = complaint_bucket)) +\n  geom_segment(aes(x = 0, xend = proportion, yend = complaint_bucket),\n               color = \"gray80\") +\n  geom_point(aes(color = borough), size = 2) +\n\n  facet_wrap(~ borough, scales = \"free_y\", ncol = 2) +\n  scale_x_continuous(labels = function(x) paste0(x, \"%\")) +\n  scale_y_reordered() +\n  scale_color_brewer(palette = \"Set2\") +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text.x = element_text(size = 7),\n    axis.text.y = element_text(size = 8),\n    plot.margin = margin(5, 30, 5, 5) # room for labels\n  ) +\n  labs(\n    title = \"Complaint Categories by Borough (Cleveland dot plot)\",\n    subtitle = \"Proportion of complaints by category within each borough\",\n    x = \"Proportion (%)\",\n    y = \"Complaint Category\"\n  ) +\n  coord_cartesian(clip = \"off\")\n\n\n\n\n\n\n\n\n\n\nWe choose Cleveland dot plot because with ~10 complaint buckets and 5 boroughs, a standard grouped bar chart would be wide and cluttered.\n\nA dot plot puts all categories on a shared horizontal scale (0–30%), which makes it easier to compare both within a borough and across boroughs.\n\nWhat stands out\n\nIn every borough, Noise Related and Vehicle and Parking are among the top categories by share, often together making up roughly one-third of complaints.\n\nManhattan is particularly noise-heavy, which matches expectations for a dense, mixed-use borough with late-night activity.\nStaten Island shows relatively more Street and Traffic Conditions and Vehicle and Parking complaints, consistent with a more car-reliant area.\n\nBuckets like Pests and Animals or Utilities and Power appear as small but visible shares everywhere; the dot plot keeps them from disappearing into an “Other” bucket.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#what-is-the-backlog-of-complaints-over-time-is-it-growing-or-shrinking",
    "href": "results.html#what-is-the-backlog-of-complaints-over-time-is-it-growing-or-shrinking",
    "title": "3  Results",
    "section": "3.3 What is the backlog of complaints over time? Is it growing or shrinking?",
    "text": "3.3 What is the backlog of complaints over time? Is it growing or shrinking?\nTo quantify how “caught up” the city is, we approximated a daily backlog:\n\nbacklog(date) ≈ cumulative complaints created − cumulative complaints closed.\n\n\n\nCode\ndf &lt;- df_clean_final   \n\n# 1) Get overall date range from created_date -------------------------------\ndate_range &lt;- df |&gt;\n  summarise(\n    start = min(as.Date(created_date), na.rm = TRUE),\n    end   = max(as.Date(created_date), na.rm = TRUE)\n  )\n\n# 2) Build daily backlog table using ONLY |&gt; --------------------------------\nbacklog &lt;- df |&gt;\n  transmute(\n    created_date = as.Date(created_date),\n    closed_date  = as.Date(closed_date)\n  ) |&gt;\n  # daily counts of created\n  count(created_date, name = \"n_created\") |&gt;\n  right_join(\n    tibble(\n      date = seq(\n        from = date_range$start,\n        to   = date_range$end,\n        by   = \"day\"\n      )\n    ),\n    by = c(\"created_date\" = \"date\")\n  ) |&gt;\n  rename(date = created_date) |&gt;\n  mutate(n_created = replace_na(n_created, 0L)) |&gt;\n  # daily counts of closed\n  left_join(\n    df |&gt;\n      filter(!is.na(closed_date)) |&gt;\n      transmute(closed_date = as.Date(closed_date)) |&gt;\n      count(closed_date, name = \"n_closed\"),\n    by = c(\"date\" = \"closed_date\")\n  ) |&gt;\n  mutate(\n    n_closed    = replace_na(n_closed, 0L),\n    cum_created = cumsum(n_created),\n    cum_closed  = cumsum(n_closed),\n    open_backlog = cum_created - cum_closed\n  )\n\n# 3) Plot -------------------------------------------------------------------\n\np_backlog &lt;- ggplot(backlog, aes(x = date, y = open_backlog)) +\n  geom_area(alpha = 0.7) +\n  geom_line(linewidth = 0.4) +\n  scale_y_continuous(\n    name = \"Cumulative count of cases \",\n    labels = label_number(scale_cut = cut_short_scale(), accuracy = 0.1)\n  ) +\n  scale_x_date(\n    name = NULL,\n    date_breaks = \"2 months\",\n    date_labels = \"%b %Y\"\n  ) +\n  labs(\n    title    = \"Cumulative Backlog of Open 311 Complaints Over Time\",\n    y=\"Time (months)\"\n  ) +\n  theme_report()\n\np_backlog\n\n\n\n\n\n\n\n\n\nWhat the backlog curve tells us\n\nBacklog starts close to zero and climbs steadily throughout 2023 and 2024.\n\nThere are short flat spots and small dips, but no long period where the city clearly catches up; by early 2025, the estimated backlog is near the 300k mark.\n\nThis means that even if individual cases close in reasonable time, new complaints have been arriving faster than they are resolved , leaving a growing stock of open work. The backlog plot is our main evidence that the 311 system is under sustained pressure rather than just dealing with a one-off spike.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#how-long-are-complaints-open-which-types-take-the-longest-to-resolve",
    "href": "results.html#how-long-are-complaints-open-which-types-take-the-longest-to-resolve",
    "title": "3  Results",
    "section": "3.4 How long are complaints open? Which types take the longest to resolve?",
    "text": "3.4 How long are complaints open? Which types take the longest to resolve?\n\n\nCode\n# 1) Reference date = latest date in the data (same as before)\nref_date &lt;- df_clean_final |&gt;\n  mutate(\n    cd  = as.Date(created_date),\n    cl  = as.Date(closed_date),\n    act = as.Date(resolution_action_updated_date)\n  ) |&gt;\n  summarise(latest = max(cd, cl, act, na.rm = TRUE)) |&gt;\n  pull(latest)\n\n# 2) Filter to currently open complaints and compute age,\n#    using complaint_bucket instead of complaint_type\nopen_age_bands &lt;- df_clean_final |&gt;\n  filter(status != \"Closed\") |&gt;\n  mutate(\n    created_date    = as.Date(created_date),\n    age_days        = as.numeric(ref_date - created_date),\n    complaint_bucket = fct_explicit_na(complaint_bucket, \"Unknown\")\n  ) |&gt;\n  filter(\n    !is.na(age_days),\n    age_days &gt;= 0,\n    age_days &lt;= 730   # cap at 2 years\n  ) |&gt;\n  mutate(\n    age_band = cut(\n      age_days,\n      breaks = c(-Inf, 7, 30, 90, 365, Inf),\n      labels = c(\"0–7 days\", \"8–30 days\", \"31–90 days\", \"91–365 days\", \"&gt;365 days\"),\n      right  = TRUE\n    )\n  ) |&gt;\n  filter(!is.na(age_band)) |&gt;\n  # optional: order buckets by median age (oldest at top of plot)\n  mutate(\n    complaint_bucket = fct_reorder(complaint_bucket, age_days, .fun = median, .na_rm = TRUE)\n  )\n\n# 3) Proportions of age bands within each complaint bucket\nage_comp_by_bucket &lt;- open_age_bands |&gt;\n  group_by(complaint_bucket, age_band) |&gt;\n  summarise(n = n(), .groups = \"drop\") |&gt;\n  group_by(complaint_bucket) |&gt;\n  mutate(share = n / sum(n)) |&gt;\n  ungroup()\n\n# --- NEW: order complaint_bucket by share of &gt;365 days ---\nbucket_order &lt;- age_comp_by_bucket |&gt;\n  filter(age_band == \"&gt;365 days\") |&gt;\n  arrange(desc(share)) |&gt;\n  pull(complaint_bucket)\n\nage_comp_by_bucket &lt;- age_comp_by_bucket |&gt;\n  mutate(\n    complaint_bucket = factor(complaint_bucket, levels = rev(bucket_order))  # descending order\n  )\n# ---------------------------------------------------------\n\n# 4) Plot: backlog composition by complaint bucket\nggplot(age_comp_by_bucket,\n       aes(x = complaint_bucket, y = share, fill = age_band)) +\n  geom_col(position = \"fill\") +\n  coord_flip() +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  scale_fill_brewer(palette = \"Blues\", name = \"Age band\") +\n  labs(\n    title = \"Open Cases: Backlog Age Composition by Complaint Bucket\",\n    x = \"Complaint bucket\",\n    y = \"Share of open complaints\"\n  ) +\n  theme_report()\n\n\n\n\n\n\n\n\n\nObservations:\n\nCategories such as “Noise Related” and “Pests and Animals” show relatively higher shares of long-standing open cases, reflecting the recurring and seasonal nature of these issues.\n\nInfrastructure-related complaints (e.g., “Utilities and Power,” “Sanitation and Waste,” “Buildings and Housing”) also maintain notable long-term backlogs, which may indicate ongoing structural or jurisdictional challenges.\n\nIn contrast, categories like “Vehicle and Parking” or “Street and Traffic Conditions” show smaller proportions of old cases, suggesting that these are typically resolved more promptly.\n\nThe consistent use of a single color palette (darker for older cases) reinforces the aging severity gradient, helping viewers immediately identify which complaint types are more delayed.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#how-do-complaints-progress-through-the-system-which-types-get-stuck",
    "href": "results.html#how-do-complaints-progress-through-the-system-which-types-get-stuck",
    "title": "3  Results",
    "section": "3.5 How do complaints progress through the system? which types get stuck?",
    "text": "3.5 How do complaints progress through the system? which types get stuck?\nNext we look at what happens after a complaint is created.\nThe alluvial (Sankey-style) diagram follows the volume of complaints from:\n\nYear (2023 vs 2024) → Complaint Type (bucket) → Final Status\n(Assigned, Closed, In Progress)\n\nEach band’s thickness represents the number of complaints flowing along that path.\n\n\nCode\n# Prepare alluvial data\ndf_viz &lt;- df_clean_final |&gt;\n  mutate(\n    year = year(created_date),\n    month = floor_date(created_date, \"month\"),\n    status_clean = ifelse(status == \"\" | status == \"Closed\", NA, status)\n  )\n\ndf_alluvial &lt;- df_viz |&gt;\n  filter(!is.na(status_clean)) |&gt;\n  count(year, complaint_bucket, status_clean)\n\n# Alluvial Plot\nggplot(\n  df_alluvial,\n  aes(\n    axis1 = year,\n    axis2 = complaint_bucket,\n    axis3 = status_clean,\n    y = n\n  )\n) +\n  geom_alluvium(aes(fill = complaint_bucket), width = 1/10, alpha = 0.8) +\n  geom_stratum(width=1/5,na.rm = TRUE,show.legend = TRUE) +\n  geom_label(\n    stat = \"stratum\",\n    aes(label = after_stat(stratum)),\n    size = 3\n  ) +\n  scale_x_discrete(\n    limits = c(\"Year\", \"Complaint Type\", \"Status\"),\n    expand = c(.05, .05)\n  ) +\n  scale_y_continuous(labels = scales::comma) +\n  labs(\n    title = \"Complaint Flow: Year → Complaint Type → Final Status\",\n    y = \"Number of Complaints\",\n    x = \"\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(face = \"bold\"),\n    axis.text.x = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\nMain patterns\n\n2023 bands are thicker than 2024 simply because more months of 2023 are in the data.\n\nFor most buckets, the majority of complaints eventually flow into Closed, but the share that remains Assigned or In Progress varies by type.\n\nComplaint buckets such as Buildings and Housing and Sanitation and Waste send a larger fraction of their volume into Assigned or In Progress compared to, say, Noise or Vehicle and Parking. That suggests more complex or slower workflows for physical-infrastructure issues.This plot gives a big-picture map of the complaint lifecycle, highlighting which categories tend to linger in the system.\n\n\n\nCode\ndf &lt;- df_clean_final |&gt;\n  mutate(\n    created_dt  = ymd_hms(created_date, quiet = TRUE, tz = \"America/New_York\"),\n    closed_dt   = ymd_hms(closed_date,  quiet = TRUE, tz = \"America/New_York\"),\n    updated_dt  = ymd_hms(resolution_action_updated_date, quiet = TRUE, tz = \"America/New_York\"),\n    date        = as_date(created_dt),\n    month       = floor_date(created_dt, \"month\"),\n    hour        = hour(created_dt),\n    wday        = wday(created_dt, label = TRUE, week_start = 1),\n\n    is_closed   = !is.na(closed_dt),\n    ttc_hours   = as.numeric(difftime(closed_dt, created_dt, units = \"hours\")),\n    ttc_days    = ttc_hours / 24,\n\n    has_geo     = !is.na(latitude) & !is.na(longitude)\n  ) |&gt;\n  filter(!is.na(created_dt))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#how-can-people-contact-311-which-channel-is-preferred-when",
    "href": "results.html#how-can-people-contact-311-which-channel-is-preferred-when",
    "title": "3  Results",
    "section": "3.6 How can people contact 311? which channel is preferred when?",
    "text": "3.6 How can people contact 311? which channel is preferred when?\nHow people submit complaints: ONLINE, PHONE, MOBILE, and OTHER.For each time-of-day shift (Late Night, Morning, Afternoon, Evening), we calculated each channel’s share of monthly complaints and plotted these as line charts in a 2×2 facet layout.\n\n\nCode\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(scales)\nlibrary(stringr)\nlibrary(forcats)\nlibrary(slider)\n\n# --- Build shift + month, clean channel ---\ncm &lt;- df |&gt;\n  transmute(\n    created_date,\n    open_data_channel_type = str_squish(open_data_channel_type)\n  ) |&gt;\n  filter(\n    !is.na(open_data_channel_type),\n    open_data_channel_type != \"\",\n    !str_to_lower(open_data_channel_type) %in% c(\"unknown\",\"unk\",\"n/a\",\"na\")\n  ) |&gt;\n  mutate(created_dt = ymd_hms(created_date, quiet = TRUE, tz = \"America/New_York\")) |&gt;\n  filter(!is.na(created_dt)) |&gt;\n  mutate(\n    month = floor_date(created_dt, \"month\"),\n    hr = hour(created_dt),\n    shift = case_when(\n      hr &lt; 6  ~ \"Late Night\",\n      hr &lt; 12 ~ \"Morning\",\n      hr &lt; 18 ~ \"Afternoon\",\n      TRUE    ~ \"Evening\"\n    ),\n    shift = factor(shift, levels = c(\"Late Night\",\"Morning\",\"Afternoon\",\"Evening\"))\n  )\n\n# --- Top 4 channels only ---\ntop4 &lt;- cm |&gt;\n  count(open_data_channel_type, sort = TRUE) |&gt;\n  slice_head(n = 4) |&gt;\n  pull(open_data_channel_type)\n\ncm &lt;- cm |&gt;\n  filter(open_data_channel_type %in% top4) |&gt;\n  mutate(channel = fct_relevel(open_data_channel_type, top4))\n\n# --- Monthly share within each shift + 3-month rolling average ---\nchannel_shift_month &lt;- cm |&gt;\n  count(month, shift, channel, name = \"n\") |&gt;\n  group_by(month, shift) |&gt;\n  mutate(share = n / sum(n)) |&gt;\n  ungroup() |&gt;\n  arrange(shift, channel, month) |&gt;\n  group_by(shift, channel) |&gt;\n  mutate(share_roll3 = slide_dbl(share, mean, .before = 1, .after = 1, .complete = FALSE)) |&gt;\n  ungroup()\n\n# --- Plot (matches your screenshot; legend on the right) ---\np_shift_channel &lt;- ggplot(\n  channel_shift_month,\n  aes(x = month, group = channel, color = channel)\n) +\n  geom_line(aes(y = share), linewidth = 0.7, alpha = 0.30) +        # thin monthly\n  geom_line(aes(y = share_roll3), linewidth = 1.35, alpha = 0.95) + # thick roll avg\n  facet_wrap(~ shift, ncol = 2, scales = \"fixed\") +\n  scale_y_continuous(\n    limits = c(0, 0.60),\n    breaks = seq(0, 0.60, by = 0.20),\n    labels = percent_format(accuracy = 1),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_x_date(\n    date_breaks = \"4 months\",\n    date_labels = \"%b %Y\",\n    expand = expansion(mult = c(0.01, 0.05))\n  ) +\n  labs(\n    title = \"311 Submission Channels by Time-of-Day Shift\",\n    subtitle = \"Channel composition varies by shift; thick lines show 3-month rolling averages to clarify trend direction (Top 4 channels; Unknown removed).\",\n    x = NULL, y = \"Share of monthly complaints\",\n    color = \"Channel\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    panel.grid.minor = element_blank(),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.spacing = unit(1.4, \"lines\"),\n    strip.text = element_text(size = 16, face = \"bold\"),\n    strip.background = element_rect(fill = \"grey92\", color = NA),\n    plot.title = element_text(face = \"bold\", size = 20),\n    plot.subtitle = element_text(size = 12),\n    plot.margin = margin(t = 14, r = 18, b = 14, l = 30),\n\n    # legend on the right\n    legend.position = \"right\",\n    legend.title = element_text(face = \"bold\"),\n    legend.key.height = unit(0.9, \"lines\"),\n    legend.key.width  = unit(1.0, \"lines\")\n  )\n\np_shift_channel\n\n\n\n\n\n\n\n\n\nBehavioural shifts we see\n\nIn the Late Night panel, ONLINE starts out dominant, but its share falls while MOBILE rises sharply, eventually becoming comparable or higher. Night-time reporting is increasingly app-based.\n\nDuring Morning and Afternoon, PHONE remains important, but MOBILE’s share inches up over the two years.\n\nEvening shows the most balanced mix, with ONLINE still strong but MOBILE gaining ground.\n\nTaken together, these lines point to a slow but clear shift towards mobile reporting, especially outside office hours, which has implications for how interfaces and follow-up communication should be designed.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#who-handles-what-interactive-boroughtypeagency-pair-plot",
    "href": "results.html#who-handles-what-interactive-boroughtypeagency-pair-plot",
    "title": "3  Results",
    "section": "3.7 Who handles what: interactive borough–type–agency “pair” plot",
    "text": "3.7 Who handles what: interactive borough–type–agency “pair” plot\nTo connect complaints to the agencies that act on them, we built an interactive Sankey diagram with four stages:\n\nBorough → Detailed Complaint Type → Agency → Status\n\nThis is the plot we think of as a pair-exploration tool: users can focus on one borough–type, type–agency, or agency–status “pair” at a time.\n\n\nCode\nd &lt;- df_clean_final |&gt;\n  transmute(\n    borough        = fct_lump_n(factor(borough), 5, other_level = \"Other\"),\n    complaint_bucket = fct_lump_n(factor(complaint_bucket), 10, other_level = \"Other\"),\n    agency_name    = fct_lump_n(factor(agency_name), 10, other_level = \"Other\"),\n    status         = fct_lump_n(factor(status), 6, other_level = \"Other\")\n  ) |&gt;\n  tidyr::drop_na(borough, complaint_bucket, agency_name, status) |&gt;\n  filter(\n    borough != \"Other\",\n    complaint_bucket != \"Other\",\n    agency_name != \"Other\",\n    status != \"Other\"\n  )\n\nd_counts &lt;- d |&gt;\n  count(borough, complaint_bucket, agency_name, status, name = \"n\") |&gt;\n  arrange(desc(n)) |&gt;\n  mutate(borough_id = as.integer(borough))\n\nborough_levels &lt;- levels(d_counts$borough)\nK &lt;- length(borough_levels)\n\npal5 &lt;- c(\"#0072B2\", \"#D55E00\", \"#009E73\", \"#CC79A7\", \"#F0E442\")\n\ndiscrete_scale &lt;- list(\n  list(0/4, pal5[1]), list(0/4, pal5[1]),\n  list(1/4, pal5[2]), list(1/4, pal5[2]),\n  list(2/4, pal5[3]), list(2/4, pal5[3]),\n  list(3/4, pal5[4]), list(3/4, pal5[4]),\n  list(4/4, pal5[5]), list(4/4, pal5[5])\n)\n  \nfig_parcats &lt;- plot_ly(\n  type = \"parcats\",\n  width = 1600, height = 800,\n  arrangement = \"freeform\",\n  dimensions = list(\n    list(label = \"Borough\",        values = d_counts$borough),\n    list(label = \"Complaint Bucket\", values = d_counts$complaint_bucket),\n    list(label = \"Agency\",         values = d_counts$agency_name),\n    list(label = \"Status\",         values = d_counts$status)\n  ),\n  counts = d_counts$n,\n  line = list(\n    color = d_counts$borough_id,\n    colorscale = discrete_scale,\n    cmin = 1, cmax = K,\n    showscale = FALSE\n  )\n)%&gt;%\n  plotly::layout(\n    title = list(\n      text = \"311 Complaint Flow: Borough → Type → Agency → Status (Colored by Borough)\",\n      x = 0.02\n    ),\n    margin = list(l = 40, r = 40, t = 60, b = 30)\n  )\n\nfig_parcats\n\n\n\n\n\n\n\nOnce we keep borough, detailed type (e.g. Illegal Parking, Noise – Residential), agency (NYPD, DOT, etc.), and status, the cross-tab becomes extremely high-dimensional.\n\nA static plot would either hide most detail or be unreadable.\n\nInteractivity (hovering to show labels and counts, highlighting a path) allows the reader to drill down without losing the full context.\n\nHow the interactivity helps\n\nHovering on Brooklyn → Illegal Parking reveals a very thick band flowing to NYPD, making it obvious that parking enforcement is overwhelmingly a police workload.\n\nHighlighting Noise – Residential quickly shows which boroughs and agencies share that burden; for example, large flows from Queens and Brooklyn again route to NYPD.\n\nSmaller but meaningful flows (for example, HEAT/HOT WATER to the housing agency) are easy to surface by hovering, even though they would be visually drowned out if everything were static.\n\nInstead of giving one fixed conclusion, this plot serves as a navigation map for responsibility: it lets a reader answer questions like “Who usually deals with this type of complaint in my borough, and how does it tend to end?”.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#where-problems-occur-and-what-type-of-complaints-are-occurring-there",
    "href": "results.html#where-problems-occur-and-what-type-of-complaints-are-occurring-there",
    "title": "3  Results",
    "section": "3.8 3.6 Where problems occur, and what type of complaints are occurring there?",
    "text": "3.8 3.6 Where problems occur, and what type of complaints are occurring there?\nWe next asked where in the city the problems are happening.\nWe focused on the top location types (e.g., RESIDENTIAL BUILDING, Street/Sidewalk, Store/Commercial, Club/Bar/Restaurant) and the top complaint types.\nFor each location, we computed the share of its complaints belonging to each type and plotted this as a heatmap with percentages printed on the tiles.\n\n\nCode\ndf1 &lt;- df_clean_final |&gt;\n  mutate(\n    location_type  = str_squish(location_type),\n    complaint_type = str_squish(complaint_type)\n  ) |&gt;\n  filter(!is.na(location_type), location_type != \"\",\n         !is.na(complaint_type), complaint_type != \"\")\n\ntop_loc &lt;- df1 |&gt; count(location_type, sort = TRUE) |&gt; slice_head(n = 10) |&gt; pull(location_type)\ntop_ct  &lt;- df1 |&gt; count(complaint_type, sort = TRUE) |&gt; slice_head(n = 15) |&gt; pull(complaint_type)\n\nhm &lt;- df1 |&gt;\n  filter(location_type %in% top_loc, complaint_type %in% top_ct) |&gt;\n  count(location_type, complaint_type, name = \"n\") |&gt;\n  group_by(location_type) |&gt;\n  mutate(share = n / sum(n)) |&gt;\n  ungroup()\n\n# --- STORY ORDERING (cluster rows/cols by similar composition) ---\nmat_wide &lt;- hm |&gt;\n  select(location_type, complaint_type, share) |&gt;\n  pivot_wider(names_from = complaint_type, values_from = share, values_fill = 0)\n\nmat &lt;- as.matrix(mat_wide[,-1, drop = FALSE])\nrownames(mat) &lt;- mat_wide$location_type\n\nrow_ord &lt;- hclust(dist(mat))$order\ncol_ord &lt;- hclust(dist(t(mat)))$order\n\nloc_levels &lt;- rownames(mat)[row_ord]\nct_levels  &lt;- colnames(mat)[col_ord]\n\nhm &lt;- hm |&gt;\n  mutate(\n    location_type  = factor(location_type, levels = loc_levels),\n    complaint_type = factor(complaint_type, levels = ct_levels),\n    # label color for readability on dark vs light tiles\n    lbl_col = if_else(share &gt;= 0.45, \"black\", \"white\")\n  )\n\nggplot(hm, aes(x = complaint_type, y = location_type, fill = share)) +\n  geom_tile(color = \"white\", linewidth = 0.25) +\n  geom_text(aes(label = percent(share, accuracy = 1), color = lbl_col),\n            size = 3.3, fontface = \"bold\") +\n  scale_color_identity() +\n  scale_fill_viridis_c(\n    option = \"plasma\",   # high-contrast, story-friendly\n    begin = 0.08, end = 0.98,\n    labels = percent_format(accuracy = 1),\n    name = \"Share\"\n  ) +\n  labs(\n    title = \"Complaint Composition by Location Type\",\n    subtitle = \"Within each location type, tiles show the share of complaints by complaint type (clustered to reveal similar patterns)\",\n    x = \"Complaint Type (top 15)\",\n    y = \"Location Type (top 10)\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    axis.text.x = element_text(angle = 35, hjust = 1),\n    panel.grid = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nLocation × complaint type is a dense matrix; heatmaps excel at summarising many cells using colour.\n\nEmbedding the percentages directly gives precise values without forcing the reader to flip back to a legend.\n\nPatterns by location\n\nFor Residential Building/House, complaints are heavily concentrated in a few types — particularly HEAT/HOT WATER and indoor cleanliness conditions — which often take up essentially the entire row.\n\nStreet/Sidewalk is dominated by Illegal Parking, Abandoned Vehicles, and outdoor sanitation issues.\n\nCommercial spaces (Store/Commercial, Club/Bar/Restaurant) are almost entirely noise and cleanliness problems.\n\nThis figure supports simple, concrete statements such as:\n&gt; “On streets and sidewalks, the story is mostly about parking and trash; inside homes, it’s about heat, water, and living conditions.” ## What is the volume of complaints received? How quickly are they resolved?##\n\n\nCode\naddr_plot &lt;- df_clean_final %&gt;%\n  mutate(\n    days_to_close = as.numeric(as.Date(closed_date) - as.Date(created_date))\n  ) %&gt;%\n  group_by(borough, incident_address) %&gt;%\n  summarise(\n    n_complaints = n(),\n    median_days  = median(days_to_close, na.rm = TRUE),\n    .groups = \"drop\"\n  ) %&gt;%\n  filter(n_complaints &gt;= 30, median_days &lt;= 500) %&gt;%\n  mutate(\n    borough = factor(\n      borough,\n      levels = c(\"MANHATTAN\", \"BROOKLYN\", \"QUEENS\", \"BRONX\", \"STATEN ISLAND\")\n    )\n  )\n\n# Single combined scatter plot (no facet)\nggplot(addr_plot, aes(x = n_complaints, y = median_days)) +\n  geom_point(size = 2.2, alpha = 0.8) +\n  scale_x_log10(\n  limits = c(20, 1000),    # widen range beyond your data\n  breaks = c(30, 50, 100, 200, 500, 1000),\n  labels = label_number(accuracy = 1)\n) +\n  labs(\n    title = \"Chronic Hotspots: Complaint Volume vs Resolution Speed\",\n    x = \"Number of complaints at Boroug (log scale)\",\n    y = \"Median days to closure (within 60 days)\",\n    color = \"Borough\"\n  ) + theme_report() \n\n\n\n\n\n\n\n\n\nObservations: This chart is designed to highlight persistent trouble spots where complaint volumes are high and resolution times vary significantly. The use of a logarithmic x-axis allows both moderately busy and highly problematic addresses to appear in the same visual frame, without letting the most extreme values dominate.\nSeveral key insights emerge:\n\nHigh-frequency complaint locations (toward the right of the x-axis) generally show shorter median resolution times, suggesting that repeatedly reported sites are often monitored more actively by response teams.\n\nScattered high-delay outliers in each borough (points above 200 days) indicate addresses where complex cases, repeated inspections, or inter-agency coordination might slow closure.\n\nThe concentration of points near the baseline (below 60 days) reinforces that the majority of chronic addresses are eventually closed within the targeted time window.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#which-agency-has-faster-resolution-time",
    "href": "results.html#which-agency-has-faster-resolution-time",
    "title": "3  Results",
    "section": "3.9 Which agency has faster resolution time?",
    "text": "3.9 Which agency has faster resolution time?\n\n\nCode\ndf_clean &lt;- df_clean_final |&gt;\n  mutate(\n    created_date = as.POSIXct(created_date),\n    closed_date = as.POSIXct(closed_date),\n    resolution_time_days = as.numeric(difftime(closed_date, created_date, units = \"days\"))\n  ) |&gt;\n  filter(!is.na(resolution_time_days), resolution_time_days &gt;= 0)\n\n# Top 15 agencies by complaint volume\ntop_agencies &lt;- df_clean |&gt;\n  count(agency_name) |&gt;\n  slice_max(n, n = 15) |&gt;\n  pull(agency_name)\n\n# Boxplot: resolution time by agency\ndf_clean |&gt;\n  filter(agency_name %in% top_agencies) |&gt;\n  mutate(agency_name = reorder(agency_name, resolution_time_days, FUN = median)) |&gt;\n  ggplot(aes(x = agency_name, y = resolution_time_days)) +\n  geom_boxplot(fill = \"steelblue\", alpha = 0.7, outlier.alpha = 0.3) +\n  coord_flip() +\n  scale_y_continuous(limits = c(0, quantile(df_clean$resolution_time_days, 0.95, na.rm = TRUE))) +\n  labs(\n    title = \"Resolution Time Distribution by Agency (Top 15)\",\n    subtitle = \"Median, quartiles, and outliers shown\",\n    x = \"Agency\",\n    y = \"Resolution Time (Days)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\nObservations:\n\nAgencies vary widely in their resolution time distributions.\nSome agencies (e.g., DOF - Department of Finance, NYPD - New York Police Department) have relatively short median resolution times, while others (e.g., DHS - Department of Homeless Services, HPD - Housing Preservation and Development) show longer medians and wider spreads.\nThe presence of outliers indicates that while many complaints are resolved quickly, a subset takes significantly longer.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "results.html#resolution-actions-by-location-type-faceted-bar-charts",
    "href": "results.html#resolution-actions-by-location-type-faceted-bar-charts",
    "title": "3  Results",
    "section": "3.10 Resolution actions by location type (faceted bar charts)",
    "text": "3.10 Resolution actions by location type (faceted bar charts)\nWe then looked at what kind of action is actually taken, and where.\nWe grouped individual resolution descriptions into a handful of broader action types (e.g., Duplicate / Already Reported, Enforcement / Summons, Inspection / Investigation, Referred / Transferred, Work Completed).\nFor each action type, we plotted a bar chart showing the share of that action occurring in each location type, with one small panel per action.\nWe excluded “No Issue Found” so the panels focus on cases where something concrete happened.\n\n\nCode\n# --- 1) Prep + tag resolution actions (same logic you used) ---\ndf3 &lt;- df_clean_final |&gt;\n  transmute(\n    location_type = str_squish(location_type),\n    resolution_description = str_squish(resolution_description)\n  ) |&gt;\n  filter(!is.na(location_type), location_type != \"\",\n         !is.na(resolution_description), resolution_description != \"\") |&gt;\n  mutate(rd = str_to_lower(resolution_description)) |&gt;\n  mutate(action_tag = case_when(\n    str_detect(rd, \"inspect|inspection|investigat|observ\") ~ \"Inspection / Investigation\",\n    str_detect(rd, \"no violation|unable to observe|could not.*verify\") ~ \"No Issue Found\",\n    str_detect(rd, \"duplicate|already reported|previously reported\") ~ \"Duplicate / Already Reported\",\n    str_detect(rd, \"summons|ticket|violation issued|enforc\") ~ \"Enforcement / Summons\",\n    str_detect(rd, \"repaired|fixed|completed|work order|restored|cleaned\") ~ \"Work Completed\",\n    str_detect(rd, \"referred|transfer|forwarded|sent to\") ~ \"Referred / Transferred\",\n    TRUE ~ \"Other Action\"\n  ))\n\n\n\n\nCode\n# Chunk 2: plot (uses df3 from above)\ntop_loc &lt;- df3 |&gt; count(location_type, sort = TRUE) |&gt; slice_head(n = 10) |&gt; pull(location_type)\n\ndf3_f &lt;- df3 |&gt; filter(action_tag != \"No Issue Found\")\n\naction_loc &lt;- df3_f |&gt;\n  filter(location_type %in% top_loc) |&gt;\n  count(action_tag, location_type, name = \"n\") |&gt;\n  group_by(action_tag) |&gt;\n  mutate(share_within_action = n / sum(n)) |&gt;\n  ungroup()\n\n# ---- ONLY change: sort x within each facet by share ----\naction_loc &lt;- action_loc |&gt;\n  group_by(action_tag) |&gt;\n  arrange(desc(share_within_action), .by_group = TRUE) |&gt;\n  mutate(location_type_sorted = factor(location_type, levels = unique(location_type))) |&gt;\n  ungroup()\n\nggplot(action_loc, aes(x = location_type_sorted, y = share_within_action, fill = action_tag)) +\n  geom_col(width = 0.82, color = \"white\", linewidth = 0.25) +\n  facet_wrap(~ action_tag, ncol = 3, scales = \"free_y\") +\n  scale_y_continuous(labels = percent_format(accuracy = 1)) +\n  scale_fill_brewer(palette = \"Set2\", guide = \"none\") +\n  labs(\n    title = \"Resolution Actions by Location Type (Faceted)\",\n    subtitle = \"Excludes “No Issue Found”. Each panel shows where that action occurs most (shares sum to 100% within each action).\",\n    x = NULL, y = \"Share within action\"\n  ) +\n  theme_minimal() +\n  theme(\n    panel.grid.minor = element_blank(),\n    axis.text.x = element_text(angle = 35, hjust = 1, size = 8),\n    strip.text = element_text(face = \"bold\"),\n    panel.spacing = unit(1.1, \"lines\"),\n\n    # ---- ONLY change: prevent facet titles from being cut ----\n    plot.margin = margin(t = 20, r = 15, b = 25, l = 15)\n  )\n\n\n\n\n\n\n\n\n\n\nConditioning on the action (“given that an action of type X happened, where did it happen?”) is a different question from the previous heatmap.\n\nFaceting by action keeps each panel simple and lets us scan across panels to see which locations dominate which actions.\n\nWhat the panels reveal\n\nDuplicate / Already Reported is almost entirely associated with Street/Sidewalk, suggesting repeated reports from passers-by at the same spot.\n\nEnforcement / Summons is heavily concentrated in public space (street, sidewalk, above-address), aligning with ticketing and code enforcement.\n\nInspection / Investigation is skewed towards RESIDENTIAL BUILDING, which is exactly where we’d expect inspectors to be dispatched.\n\nWork Completed shows a mix of residential and street locations, highlighting where city crews most often finish tangible tasks.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Results</span>"
    ]
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "4  Conclusion",
    "section": "",
    "text": "Main Takeaways: 311 complaints in NYC exhibit distinct patterns in terms of types, resolution times, and geographic distribution. Key complaint categories such as noise, sanitation, and infrastructure dominate the dataset, with significant variations in how quickly different types are addressed. The analysis highlights that certain complaint types tend to remain open longer, indicating potential areas for process improvement.\nLimitations: Our analysis focuses on data from a specific timeframe (2023-2024) and may not capture seasonal or long-term trends. Additionally, the dataset relies on self-reported complaints, which affects the quality and completeness of the information.\nFuture Directions: Capture 5 years of data to analyze trends over time. Incoporate population density and demographic data to understand complaint patterns better.\nLessons Learned: Data cleaning and preprocessing are critical for accurate analysis, especially with large, real-world datasets. Geospatial enrichment adds valuable context to urban data, enhancing interpretability.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conclusion</span>"
    ]
  }
]